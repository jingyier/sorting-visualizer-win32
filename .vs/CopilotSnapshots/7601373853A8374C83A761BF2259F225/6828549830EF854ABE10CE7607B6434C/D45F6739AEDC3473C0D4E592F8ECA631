#include <windows.h>
#include <cstdio>
#include <vector>
#include "resource.h"

#define MAXSIZE 100

typedef struct { int comps; int moves; } Stats;
static inline void swap_int(int* a, int* b, Stats* s) { int t = *a; s->moves++; *a = *b; s->moves++; *b = t; s->moves++; }
static inline int less_than(int a, int b, Stats* s) { s->comps++; return a < b; }
static inline int greater_than(int a, int b, Stats* s) { s->comps++; return a > b; }

static void gen_random(std::vector<int>& a, int n, unsigned seed, int range) { a.resize(n); srand(seed); for (int i = 0; i < n; ++i)a[i] = rand() % (range > 0 ? range : 1); }
static void copy_array(const std::vector<int>& src, std::vector<int>& dst) { dst = src; }

static void bubble_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; int n = (int)a.size(); for (int i = 0; i < n - 1; ++i) { int swapped = 0; for (int j = 0; j < n - 1 - i; ++j) { if (greater_than(a[j], a[j + 1], s)) { swap_int(&a[j], &a[j + 1], s); swapped = 1; } } if (!swapped)break; } }
static void insertion_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; int n = (int)a.size(); for (int i = 1; i < n; ++i) { int key = a[i]; s->moves++; int j = i - 1; while (j >= 0 && greater_than(a[j], key, s)) { a[j + 1] = a[j]; s->moves++; --j; } a[j + 1] = key; s->moves++; } }
static void selection_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; int n = (int)a.size(); for (int i = 0; i < n - 1; ++i) { int minIdx = i; for (int j = i + 1; j < n; ++j) if (less_than(a[j], a[minIdx], s)) minIdx = j; if (minIdx != i) swap_int(&a[i], &a[minIdx], s); } }
static void quick_sort_rec(std::vector<int>& a, int l, int r, Stats* s) { if (l >= r)return; int pivot = a[l]; s->moves++; int lt = l, i = l + 1, gt = r; while (i <= gt) { if (less_than(a[i], pivot, s)) { swap_int(&a[i], &a[lt], s); ++lt; ++i; } else if (less_than(pivot, a[i], s)) { swap_int(&a[i], &a[gt], s); --gt; } else { ++i; } } quick_sort_rec(a, l, lt - 1, s); quick_sort_rec(a, gt + 1, r, s); }
static void quick_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; if (!a.empty()) quick_sort_rec(a, 0, (int)a.size() - 1, s); }
static void shell_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; int n = (int)a.size(); for (int gap = n / 2; gap > 0; gap /= 2) { for (int i = gap; i < n; ++i) { int key = a[i]; s->moves++; int j = i - gap; while (j >= 0 && greater_than(a[j], key, s)) { a[j + gap] = a[j]; s->moves++; j -= gap; } a[j + gap] = key; s->moves++; } } }
static void heapify_down(std::vector<int>& a, int n, int i, Stats* s) { while (true) { int largest = i, l = i * 2 + 1, r = i * 2 + 2; if (l < n && less_than(a[largest], a[l], s)) largest = l; if (r < n&& less_than(a[largest], a[r], s)) largest = r; if (largest == i) break; swap_int(&a[i], &a[largest], s); i = largest; } }
static void heap_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; int n = (int)a.size(); for (int i = n / 2 - 1; i >= 0; --i) heapify_down(a, n, i, s); for (int end = n - 1; end > 0; --end) { swap_int(&a[0], &a[end], s); heapify_down(a, end, 0, s); } }

static void AppendText(HWND hDlg, int editId, const wchar_t* text) { HWND hEdit = GetDlgItem(hDlg, editId); int len = GetWindowTextLengthW(hEdit); SendMessageW(hEdit, EM_SETSEL, (WPARAM)len, (LPARAM)len); SendMessageW(hEdit, EM_REPLACESEL, FALSE, (LPARAM)text); }

static void OnRun(HWND hDlg) {
    BOOL okN = FALSE, okSeed = FALSE, okRange = FALSE;
    UINT n = GetDlgItemInt(hDlg, IDC_EDIT_N, &okN, FALSE);
    UINT seed = GetDlgItemInt(hDlg, IDC_EDIT_SEED, &okSeed, FALSE);
    UINT range = GetDlgItemInt(hDlg, IDC_EDIT_RANGE, &okRange, FALSE);
    if (!okN || !okSeed || !okRange || n == 0 || n > MAXSIZE) { MessageBoxW(hDlg, L"请输入合法的 N/Seed/Range（N在1~100）。", L"提示", MB_ICONWARNING); return; }

    std::vector<int> base; gen_random(base, (int)n, seed, (int)range);
    std::vector<int> a; Stats sb{}, si{}, ss{}, sq{}, sh{}, shp{};
    wchar_t buf[256];

    copy_array(base, a); bubble_sort(a, &sb);
    copy_array(base, a); insertion_sort(a, &si);
    copy_array(base, a); selection_sort(a, &ss);
    copy_array(base, a); quick_sort(a, &sq);
    copy_array(base, a); shell_sort(a, &sh);
    copy_array(base, a); heap_sort(a, &shp);

    swprintf(buf, 256, L"\n=== 测试: n=%u seed=%u range=%u ===\n", n, seed, range); AppendText(hDlg, IDC_EDIT_OUT, buf);
    swprintf(buf, 256, L"Bubble   | comps=%d moves=%d\n", sb.comps, sb.moves); AppendText(hDlg, IDC_EDIT_OUT, buf);
    swprintf(buf, 256, L"Insertion | comps=%d moves=%d\n", si.comps, si.moves); AppendText(hDlg, IDC_EDIT_OUT, buf);
    swprintf(buf, 256, L"Selection | comps=%d moves=%d\n", ss.comps, ss.moves); AppendText(hDlg, IDC_EDIT_OUT, buf);
    swprintf(buf, 256, L"Quick      | comps=%d moves=%d\n", sq.comps, sq.moves); AppendText(hDlg, IDC_EDIT_OUT, buf);
    swprintf(buf, 256, L"Shell      | comps=%d moves=%d\n", sh.comps, sh.moves); AppendText(hDlg, IDC_EDIT_OUT, buf);
    swprintf(buf, 256, L"Heap       | comps=%d moves=%d\n", shp.comps, shp.moves); AppendText(hDlg, IDC_EDIT_OUT, buf);
}

static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_INITDIALOG:
        SetDlgItemInt(hDlg, IDC_EDIT_N, 50, FALSE);
        SetDlgItemInt(hDlg, IDC_EDIT_SEED, 12345, FALSE);
        SetDlgItemInt(hDlg, IDC_EDIT_RANGE, 1000, FALSE);
        return TRUE;
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_BTN_RUN:   OnRun(hDlg); return TRUE;
        case IDC_BTN_CLEAR: SetDlgItemTextW(hDlg, IDC_EDIT_OUT, L""); return TRUE;
        case IDCANCEL: EndDialog(hDlg, 0); return TRUE;
        }
        break;
    case WM_CLOSE: EndDialog(hDlg, 0); return TRUE;
    }
    return FALSE;
}

int APIENTRY wWinMain(HINSTANCE hInst, HINSTANCE, LPWSTR, int) {
    INT_PTR ret = DialogBoxParamW(hInst, MAKEINTRESOURCEW(IDD_MAIN), NULL, DlgProc, 0);
    if (ret == -1) {
        DWORD err = GetLastError();
        wchar_t buf[128];
        swprintf(buf, 128, L"DialogBoxParamW 失败，错误码 = %lu", err);
        MessageBoxW(NULL, buf, L"错误", MB_ICONERROR);
    }
    return (int)ret;
}