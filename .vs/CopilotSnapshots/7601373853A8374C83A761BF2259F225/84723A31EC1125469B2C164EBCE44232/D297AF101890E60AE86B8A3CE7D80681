#include <windows.h>
#include <cstdio>
#include <vector>
#include "resource.h"

#define MAXSIZE 100

typedef struct { int comps; int moves; } Stats;
static inline void swap_int(int* a, int* b, Stats* s) { int t = *a; s->moves++; *a = *b; s->moves++; *b = t; s->moves++; }
static inline int less_than(int a, int b, Stats* s) { s->comps++; return a < b; }
static inline int greater_than(int a, int b, Stats* s) { s->comps++; return a > b; }

static void gen_random(std::vector<int>& a, int n, unsigned seed, int range) { a.resize(n); srand(seed); for (int i = 0; i < n; ++i)a[i] = rand() % (range > 0 ? range : 1); }
static void copy_array(const std::vector<int>& src, std::vector<int>& dst) { dst = src; }

static void bubble_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; int n = (int)a.size(); for (int i = 0; i < n - 1; ++i) { int swapped = 0; for (int j = 0; j < n - 1 - i; ++j) { if (greater_than(a[j], a[j + 1], s)) { swap_int(&a[j], &a[j + 1], s); swapped = 1; } } if (!swapped)break; } }
static void insertion_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; int n = (int)a.size(); for (int i = 1; i < n; ++i) { int key = a[i]; s->moves++; int j = i - 1; while (j >= 0 && greater_than(a[j], key, s)) { a[j + 1] = a[j]; s->moves++; --j; } a[j + 1] = key; s->moves++; } }
static void selection_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; int n = (int)a.size(); for (int i = 0; i < n - 1; ++i) { int minIdx = i; for (int j = i + 1; j < n; ++j) if (less_than(a[j], a[minIdx], s)) minIdx = j; if (minIdx != i) swap_int(&a[i], &a[minIdx], s); } }
static void quick_sort_rec(std::vector<int>& a, int l, int r, Stats* s) { if (l >= r)return; int pivot = a[l]; s->moves++; int lt = l, i = l + 1, gt = r; while (i <= gt) { if (less_than(a[i], pivot, s)) { swap_int(&a[i], &a[lt], s); ++lt; ++i; } else if (less_than(pivot, a[i], s)) { swap_int(&a[i], &a[gt], s); --gt; } else { ++i; } } quick_sort_rec(a, l, lt - 1, s); quick_sort_rec(a, gt + 1, r, s); }
static void quick_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; if (!a.empty()) quick_sort_rec(a, 0, (int)a.size() - 1, s); }
static void shell_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; int n = (int)a.size(); for (int gap = n / 2; gap > 0; gap /= 2) { for (int i = gap; i < n; ++i) { int key = a[i]; s->moves++; int j = i - gap; while (j >= 0 && greater_than(a[j], key, s)) { a[j + gap] = a[j]; s->moves++; j -= gap; } a[j + gap] = key; s->moves++; } } }
static void heapify_down(std::vector<int>& a, int n, int i, Stats* s) { while (true) { int largest = i, l = i * 2 + 1, r = i * 2 + 2; if (l < n && less_than(a[largest], a[l], s)) largest = l; if (r < n&& less_than(a[largest], a[r], s)) largest = r; if (largest == i) break; swap_int(&a[i], &a[largest], s); i = largest; } }
static void heap_sort(std::vector<int>& a, Stats* s) { s->comps = s->moves = 0; int n = (int)a.size(); for (int i = n / 2 - 1; i >= 0; --i) heapify_down(a, n, i, s); for (int end = n - 1; end > 0; --end) { swap_int(&a[0], &a[end], s); heapify_down(a, end, 0, s); } }

static void AppendText(HWND hDlg, int editId, const wchar_t* text) { HWND hEdit = GetDlgItem(hDlg, editId); int len = GetWindowTextLengthW(hEdit); SendMessageW(hEdit, EM_SETSEL, (WPARAM)len, (LPARAM)len); SendMessageW(hEdit, EM_REPLACESEL, FALSE, (LPARAM)text); }

static void PrintLine(HWND hDlg, const wchar_t* text)
{
    AppendText(hDlg, IDC_EDIT_OUT, text);
    AppendText(hDlg, IDC_EDIT_OUT, L"\r\n");
}

static void OnRun(HWND hDlg) {
    BOOL okN = FALSE, okSeed = FALSE, okRange = FALSE;
    UINT n = GetDlgItemInt(hDlg, IDC_EDIT_N, &okN, FALSE);
    UINT seed = GetDlgItemInt(hDlg, IDC_EDIT_SEED, &okSeed, FALSE);
    UINT range = GetDlgItemInt(hDlg, IDC_EDIT_RANGE, &okRange, FALSE);
    if (!okN || !okSeed || !okRange || n == 0 || n > MAXSIZE) { MessageBoxW(hDlg, L"请输入合法的 N/Seed/Range（N在1~100）。", L"提示", MB_ICONWARNING); return; }

    std::vector<int> base; gen_random(base, (int)n, seed, (int)range);
    std::vector<int> a; Stats sb{}, si{}, ss{}, sq{}, sh{}, shp{};
    wchar_t buf[256];

    copy_array(base, a); bubble_sort(a, &sb);
    copy_array(base, a); insertion_sort(a, &si);
    copy_array(base, a); selection_sort(a, &ss);
    copy_array(base, a); quick_sort(a, &sq);
    copy_array(base, a); shell_sort(a, &sh);
    copy_array(base, a); heap_sort(a, &shp);

    // 清晰分块输出
    PrintLine(hDlg, L"=== 实验参数 ===");
    swprintf(buf, 256, L"n = %u, seed = %u, range = %u", n, seed, range); PrintLine(hDlg, buf);
    PrintLine(hDlg, L"");

    // 说明算法缩写
    PrintLine(hDlg, L"算法缩写: B=冒泡, I=插入, S=选择, Q=快速, H=希尔, HP=堆");
    PrintLine(hDlg, L"");

    // 实测表格（使用 ASCII 缩写，保证等宽字体对齐）
    PrintLine(hDlg, L"=== 实测统计（当前随机数据） ===");
    PrintLine(hDlg, L"Alg |   comps(比较)   |   moves(移动)");
    PrintLine(hDlg, L"---------------------------------------");

    swprintf(buf, 256, L"%-3S | %13d | %13d", "B",  sb.comps,  sb.moves);  PrintLine(hDlg, buf);
    swprintf(buf, 256, L"%-3S | %13d | %13d", "I",  si.comps,  si.moves);  PrintLine(hDlg, buf);
    swprintf(buf, 256, L"%-3S | %13d | %13d", "S",  ss.comps,  ss.moves);  PrintLine(hDlg, buf);
    swprintf(buf, 256, L"%-3S | %13d | %13d", "Q",  sq.comps,  sq.moves);  PrintLine(hDlg, buf);
    swprintf(buf, 256, L"%-3S | %13d | %13d", "H",  sh.comps,  sh.moves);  PrintLine(hDlg, buf);
    swprintf(buf, 256, L"%-3S | %13d | %13d", "HP", shp.comps, shp.moves); PrintLine(hDlg, buf);

    PrintLine(hDlg, L"");

    // 理论复杂度表格（汉语化说明）
    PrintLine(hDlg, L"=== 理论复杂度（用 n 表示，粗略） ===");
    PrintLine(hDlg, L"Alg | 时间复杂度              | 比较 / 移动 次数近似公式");
    PrintLine(hDlg, L"--------------------------------------------------------------------------");
    PrintLine(hDlg, L"B   | O(n^2)                  | 比较约为 n(n-1)/2，元素移动次数数量级为 n^2");
    PrintLine(hDlg, L"I   | O(n^2)                  | 平均比较/移动次数数量级为 n^2，最好情况为 n");
    PrintLine(hDlg, L"S   | O(n^2)                  | 比较固定约为 n(n-1)/2，交换次数不超过 3(n-1)");
    PrintLine(hDlg, L"Q   | O(nlogn),最坏 O(n^2)    | 平均比较/移动次数为 nlogn 数量级, 最坏退化到 n^2");
    PrintLine(hDlg, L"H   | 约 O(n^{1.5})~O(n^2)    | 具体次数依赖增量序列, 一般介于 nlogn 和 n^2 之间");
    PrintLine(hDlg, L"HP  | O(nlogn)                | 建堆+多次下滤, 总体比较/移动次数为 nlogn 数量级");
}

static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_INITDIALOG:
        SetDlgItemInt(hDlg, IDC_EDIT_N, 50, FALSE);
        SetDlgItemInt(hDlg, IDC_EDIT_SEED, 12345, FALSE);
        SetDlgItemInt(hDlg, IDC_EDIT_RANGE, 1000, FALSE);

        // 使用等宽英文字体，方便 ASCII 表格对齐
        {
            HFONT hFont = (HFONT)GetStockObject(ANSI_FIXED_FONT);
            if (hFont)
            {
                SendMessage(GetDlgItem(hDlg, IDC_EDIT_OUT), WM_SETFONT, (WPARAM)hFont, TRUE);
            }
        }

        return TRUE;
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_BTN_RUN:   OnRun(hDlg); return TRUE;
        case IDC_BTN_CLEAR: SetDlgItemTextW(hDlg, IDC_EDIT_OUT, L""); return TRUE;
        case IDCANCEL:
        case IDOK: EndDialog(hDlg, 0); return TRUE;
        }
        break;
    case WM_CLOSE: EndDialog(hDlg, 0); return TRUE;
    }
    return FALSE;
}

int APIENTRY wWinMain(HINSTANCE hInst, HINSTANCE, LPWSTR, int) {
    INT_PTR ret = DialogBoxParamW(hInst, MAKEINTRESOURCEW(IDD_MAIN), NULL, DlgProc, 0);
    if (ret == -1) {
        DWORD err = GetLastError();
        wchar_t buf[128];
        swprintf(buf, 128, L"DialogBoxParamW 失败，错误码 = %lu", err);
        MessageBoxW(NULL, buf, L"错误", MB_ICONERROR);
    }
    return (int)ret;
}